[[["91d547fe-c422-43b9-87cc-fb96a439735b",{"pageContent":"Unit II -Programming Shared Address Space Platforms:\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.\n  \nCS72-MCA\n\nDistributed memory systems\nDistributed memory\nEach processorhas its own private memory.\nComputational tasks can only operate on local \ndata,\nif remote data is required, \nthe computational task must communicate \nwith one or more remote processors.\nCommunication through the message passing.\nRecap\n \n \nFig: A multiprocessor system with a distributed memory (loosely coupled \nsystem)\nCS72-MCA\n\nShared memory systems\nA multiprocessor system with shared memory (tightly coupled system)\nRecap\nall processors can access all the main memory address space.\nShared variables access in the main memory\nFetching instructions for execution in processors is also done from a \nshared memory\n  \nCS72-MCA","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":0,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_0_1764046150963","subject":"map"}}],["76767869-7e4f-4562-8efa-443b0bb346a5",{"pageContent":"Threaded Programming Models\n•Library-based models —\n•all data is shared, unless otherwise specified \n•Examples: Pthreads, Intel Threading Building Blocks, Java Concurrency, Boost, \nMicrosoft .NetTask Parallel Library •\n•Directive-based models\n•e.g., OpenMP—shared and private data —\n•Thread creation and synchronization \n•Programming languages —\n•CilkPlus (Intel, GCC) —CUDA (NVIDIA) —Habanero-Java (Rice/Georgia Tech)\n \n\nParallel Programming\n1.Synchronization between concurrent tasks \n2.Communication of intermediate results\nShared address space architectures -\n-Implicitly specified since some (or all) of the memory is accessible to all the processors.\n-Threadsassume that all memory is global\n \n\nThread Basics\n•A thread is a single stream of control in the flow of a program  and it \nis a basic unit of CPU utilization.\nThread\n•Thread ID\n•Program counter\n•Register \n•setStack\nShares resources with other threads within the same process","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":1,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_1_1764046150963","subject":"map"}}],["7e2333b9-d204-40c2-b1b6-d42c4a22f88f",{"pageContent":"Thread Basics \n•The logical machine model of a thread-based programming paradigm. \n\nWhy Threads?\n•Threads provide software portability. \n•Inherent support for latency hiding. \n•Scheduling and load balancing. \n•Ease of programming and widespread use. \n \n\n•for (row = 0; row < n; row++) \nfor (column = 0; column < n; column++) \nc[row][column] = \ndot_product( get_row(a, row), \nget_col(b, col)); \ncan be transformed to: \nfor (row = 0; row < n; row++) \nfor (column = 0; column < n; column++) \nc[row][column] = \ncreate_thread( dot_product(get_row(a, \nrow),    get_col(b, \ncol))); \nProduct of two dense matrices of size n x n.\nhttps://www.tiny.cc/bhh  \nCS72-MCA\n\nThe POSIX Thread API\n•Number of vendors provide vendor-specific thread APIs\n•Pthreads-IEEE specifies a standard 1003.1c-1995, POSIX API\n•POSIX has emerged as the standard threads API\n•Other thread API: NT threads, Solaris threads, Java threads, etc","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":2,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_2_1764046150963","subject":"map"}}],["c8084ab5-2637-4dc7-96e2-d1126e9f381f",{"pageContent":"Thread Basics: Creation and Termination \n•Pthreads provides two basic functions for specifying concurrency in a \nprogram: \n#include <pthread.h> \nint pthread_create ( \npthread_t *thread_handle, const pthread_attr_t *attribute, \nvoid * (*thread_function)(void *), \nvoid *arg); \nint pthread_join ( \npthread_t thread, \nvoid **ptr); \n•The function pthread_create invokes function thread_function as a \nthread \n\nCreate thread\n•intpthread_create( pthread_t*thread, pthread_attr_t*attr,       void \n*(*thread_function)(void *), void *arg);\n•1st arg–pointer to the identifier of the created thread\n•2nd arg–thread attributes. If null, then the thread is created with default \nattributes\n•3rd arg–pointer to the function the thread will execute\n•4th arg–the argument of the executed function\n•returns 0 for success","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":3,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_3_1764046150963","subject":"map"}}],["106c7c2f-0848-439d-b9c6-983b3311faa7",{"pageContent":"Waiting threads\nintpthread_join( pthread_tthread, void **thread_return)\n•main thread will wait for daughter thread threadto finish\n•1st arg–the thread to wait for\n•2nd arg–pointer to a pointer to the return value from the thread\n•returns 0 for success\n•threads should always be joined; otherwise, a thread might keep on running even \nwhen the main thread has already terminated\n\nEstimating Pi using the Monte Carlo Method\nThe area of the circle is πr\n2\n,\nThe area of the square is width\n2\n= (2r)\n2\n= 4r\n2\n. \nIf we divide the area of the circle, by the area \nof the square we get π/4.\n \nπ ≈ 4 x (number of points in the circle / total number of points)\n  \nCS72-MCA","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":4,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_4_1764046150963","subject":"map"}}],["d547c541-34dd-442c-9a33-86158be61145",{"pageContent":"Thread Basics: Creation and Termination \n(Example) \n#include <pthread.h> \n#include <stdlib.h> \n#define MAX_THREADS 512 \nvoid *compute_pi (void *); \n.... \nmain() { \n... \npthread_t p_threads[MAX_THREADS]; \npthread_attr_t attr; \npthread_attr_init (&attr); \nfor (i=0; i< num_threads; i++) { \nhits[i] = i; \npthread_create(&p_threads[i], &attr, compute_pi, \n(void *) &hits[i]); \n} \nfor (i=0; i< num_threads; i++) { \npthread_join(p_threads[i], NULL); \ntotal_hits += hits[i]; \n} \n... \n} \n\nThread Basics: Creation and Termination \n(Example) \n#include <pthread.h> \n#include <stdlib.h> \n#define MAX_THREADS 512 \nvoid *compute_pi (void *); \n.... \nmain() { \n... \npthread_t p_threads[MAX_THREADS]; \npthread_attr_t attr; \npthread_attr_init (&attr); \nfor (i=0; i< num_threads; i++) { \nhits[i] = i; \npthread_create(&p_threads[i], &attr, compute_pi, \n(void *) &hits[i]); \n} \nfor (i=0; i< num_threads; i++) { \npthread_join(p_threads[i], NULL); \ntotal_hits += hits[i]; \n} \n... \n} \n\n \nCS72-MCA","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":5,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_5_1764046150963","subject":"map"}}],["f496454c-2564-4493-be24-b532d98429ce",{"pageContent":"CS72-MCA\n\nThread Basics: Creation and Termination \n(Example) \nvoid *compute_pi(void *s) { \nintseed, i, *hit_pointer; \ndouble rand_no_x, rand_no_y; \nintlocal_hits; \nhit_pointer= (int*) s; \nseed = *hit_pointer; \nlocal_hits= 0; \nfor (i= 0; i< sample_points_per_thread; i++) { \nrand_no_x=(double)(rand_r(&seed))/(double)((2<<14)-1); \nrand_no_y=(double)(rand_r(&seed))/(double)((2<<14)-1); \nif (((rand_no_x-0.5) * (rand_no_x-0.5) + \n(rand_no_y-0.5) * (rand_no_y-0.5)) < 0.25) \nlocal_hits++; \nseed *= i; \n} \n*hit_pointer= local_hits; \npthread_exit(0); \n}\n\nProgramming and Performance Notes \n•Note the use of the function rand_r(instead of superior random \nnumber generators such as drand48). \n•Executing this on a 4-processor SGI Origin, we observe a 3.91 fold \nspeedup at 32 threads. This corresponds to a parallel efficiency of \n0.98! \n•We can also modify the program slightly to observe the effect of false-\nsharing. \n•The program can also be used to assess the secondary cache line size.","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":6,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_6_1764046150963","subject":"map"}}],["d80dd31d-f94c-41dc-b049-c14fdd271b30",{"pageContent":"Programming and Performance Notes \n•Execution time of the compute_piprogram.\n\nSynchronization Primitives in Pthreads\n•Tasks work together to manipulate data and accomplish a given task. \n•When multiple threads attempt to manipulate the same data item the \nresults can often be incoherent if proper care is not taken to synchronize \nthem \n•Much of the effort associated with writing correct threaded programs is \nspent on synchronizing concurrent threads with respect to their data \naccesses or scheduling\nMutual Exclusion for Shared Variables\nhttps://www.tiny.cc/bhh \nCS72-MCA","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":7,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_7_1764046150963","subject":"map"}}],["b1dc0552-7446-4aa8-a51d-fde8b1eb60f4",{"pageContent":"•Assume that there are two threads, \n•The initial value of best_costis 100, \n•The values of my_costare 50 and 75 at threads t1 and t2, respectively. \n•If both threads execute the condition inside the if statement concurrently, then both threads \nenter the then part of the statement. \n•Depending on which thread executes first, the value of best_costat the end could be either \n50 or 75. \nhttps://www.tiny.cc/bhh  \nCS72-MCA\n\nThere are two problems here:\n1. non-deterministic nature of the result;\n2. more importantly, the value 75 of best_cost is inconsistent in the sense that\n  no serialization of the two threads can possibly yield this result.\nResult of the computation depends on the race between competing\n    threads\n• Critical segment- segment that must be executed by only one thread at any\n    time.\n• Threaded APIs provide support for implementing critical sections and\n    atomic operations using\nmutex-locks\nhttps://www.tiny.cc/bhh CS72-MCA","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":8,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_8_1764046150963","subject":"map"}}],["8f5af811-97fc-4ef2-a1c6-38fe6affd99a",{"pageContent":"•Critical segments in Pthreadsare implemented using mutexlocks. \n•Mutex-locks have two states:\n•locked and unlocked\n•At any point of time, only one thread can lock a mutexlock. A lock is an \natomic operation. \n•A thread entering a critical segment first tries to get a lock. It goes \nahead when the lock is granted. \nMutual Exclusion \n\nMutual Exclusion \nThe PthreadsAPI provides the following functions for handling mutex-\nlocks: \nintpthread_mutex_lock( \npthread_mutex_t*mutex_lock); \nintpthread_mutex_unlock(\npthread_mutex_t*mutex_lock); \nintpthread_mutex_init( \npthread_mutex_t*mutex_lock, \nconst pthread_mutexattr_t*lock_attr);","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":9,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_9_1764046150963","subject":"map"}}],["d43bb26b-054c-4c95-ad36-2071066b1437",{"pageContent":"Mutual Exclusion\n•We can now write our previously incorrect code segment as: \npthread_mutex_tminimum_value_lock; \n... \nmain() { \n.... \npthread_mutex_init(&minimum_value_lock, NULL);\n.... \n} \nvoid *find_min(void *list_ptr) { \n.... \npthread_mutex_lock(&minimum_value_lock); \nif (my_min< minimum_value) \nminimum_value= my_min; \n/* and unlock the mutex*/ \npthread_mutex_unlock(&minimum_value_lock); \n} \nfunction to initialize a mutex-lock to its \nunlocked state\n•If the mutex-lock is already locked, the\ncalling thread blocks\n•otherwise the mutex-lock is locked and \nthe calling thread returns\n•a thread must unlock the mutex-lock  \n•If it does not do so, no other thread will be able to \nenter this section,\n•(typically resulting deadlock.)","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":10,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_10_1764046150963","subject":"map"}}],["e1e99f21-fc17-4c78-8ab4-93ffaa8a3b58",{"pageContent":"Producer-Consumer Using Locks \n•The producer-consumer scenario imposes the following constraints: \n•The producer thread must not overwrite the shared buffer when the \nprevious task has not been picked up by a consumer thread. \n•The consumer threads must not pick up tasks until there is something \npresent in the shared data structure. \n•Individual consumer threads should pick up tasks one at a time.\nConstraints \n\nMutexTypes \n•Normal \n•—thread deadlocks if tries to lock a mutexit already has locked \n•Recursive \n•—single thread may lock a mutexas many times as it wants –\nincrements a count on the number of locks —thread relinquishes \nlock when mutexcount becomes zero \n•Errorcheck\n•—report error when a thread tries to lock a mutexit already \nlocked —report error if a thread unlocks a mutexlocked by \nanother\npthread_mutex_init(&minimum_value_lock, NULL);\nMutexTypes","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":11,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_11_1764046150963","subject":"map"}}],["ba3e9357-d6e5-4056-9b1a-6c45e8c148be",{"pageContent":"Overheads of Locking \n•Locks represent serialization points since critical sections must be executed by \nthreads one after the other. \n•Encapsulating large segments of the program within locks can lead to significant \nperformance degradation. \n•It is often possible to reduce the idling overhead associated with locks using an \nalternate function, pthread_mutex_trylock. \nintpthread_mutex_trylock(pthread_mutex_t*mutex_lock); \n•pthread_mutex_trylockis typically much faster than \npthread_mutex_lockon typical systems s\n•since it does not have to deal with queues associated with locks for multiple threads waiting on \nthe lock. \n•enables a thread to do something else if a lock is unavailable","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":12,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_12_1764046150963","subject":"map"}}],["9c2ebd93-3c48-4b08-a453-582dbbf30502",{"pageContent":"Alleviating Locking Overhead (Example) \n/* Finding k matches in a list */ \nvoid *find_entries(void *start_pointer) { \n/* This is the thread function */ \nstructdatabase_record*next_record; \nintcount; \ncurrent_pointer= start_pointer; \ndo { \nnext_record= find_next_entry(current_pointer); \ncount = output_record(next_record); \n} while (count < requested_number_of_records); \n} \nintoutput_record(structdatabase_record*record_ptr) { \nintcount; \npthread_mutex_lock(&output_count_lock); \noutput_count++; \ncount = output_count; \npthread_mutex_unlock(&output_count_lock); \nif (count <= requested_number_of_records) \nprint_record(record_ptr); \nreturn (count); \n}","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":13,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_13_1764046150963","subject":"map"}}],["ecd818d8-7e43-4d07-80d9-6ef85c08e3f0",{"pageContent":"Alleviating Locking Overhead (Example) \n/* rewritten output_recordfunction */ \nintoutput_record(structdatabase_record*record_ptr) { \nintcount; \nintlock_status; \nlock_status=pthread_mutex_trylock(&output_count_lock); \nif (lock_status== EBUSY) { \ninsert_into_local_list(record_ptr); \nreturn(0); \n} \nelse { \ncount = output_count; \noutput_count+= number_on_local_list+ 1; \npthread_mutex_unlock(&output_count_lock); \nprint_records(record_ptr, local_list, \nrequested_number_of_records-count); \nreturn(count + number_on_local_list+ 1); \n} \n} \n\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.\n\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":14,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_14_1764046150963","subject":"map"}}],["5520f5d9-606a-4f5c-92ef-df7e720b8ecf",{"pageContent":"Condition Variables for Synchronization\n• A condition variable is a data object used for synchronizing threads \n• This variable allows a thread to block itself until specified data\n    reaches a predefined state\n• Always use condition variables together with a mutex lock.\nThe shared variable task_available must become 1 before the consumer threads can be \nsignaled.\nThe boolean condition task_available == 1 is referred to as a predicate.\n• The condition variables to atomically block threads until a \nparticular condition is true.","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":15,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_15_1764046150963","subject":"map"}}],["c1c5497f-cbd0-4022-9e52-6892f8932370",{"pageContent":"Condition Variables for Synchronization\n•If the predicate is not true, the thread waits on the condition variable associated \nwith the predicate using the function pthread_cond_wait. \n•intpthread_cond_wait(pthread_cond_t*cond, pthread_mutex_t\n*mutex);\n•A call to this function blocks the execution of the thread until it receives a \nsignal from another thread\nintpthread_cond_signal(pthread_cond_t*cond);\n1. Unblocks at least one thread that is currently waiting on the condition variablecond.\n2. The producer then relinquishes its lock on mutexby explicitly calling pthread_mutex_unlock\n3. allowing one of the blocked consumer threads to consume the task\nintpthread_cond_broadcast(pthread_cond_t*cond);\nwake all threads that are waiting on the condition variable","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":16,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_16_1764046150963","subject":"map"}}],["1ec7cb16-97c1-42e6-8f5e-65a6108ecc7d",{"pageContent":"•Using a condition variable —\n•thread can block itself until a condition becomes true\n•thread locks a mutex\n•tests a predicate defined on a shared variable if predicate is false, then wait on the \ncondition variable waiting on condition variable unlocks associated mutex\n•when some thread makes a predicate true\n•Thread can signal the condition variable to either wake one waiting thread wake all \nwaiting threads\n•–when thread releases the mutex, it is passed to first waiter\nhttps://www.tiny.cc/bhh                                                  \nCS72-HPC","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":17,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_17_1764046150963","subject":"map"}}],["94dc3167-2b70-4a5f-a572-fd4c99d8f511",{"pageContent":"intpthread_cond_init(pthread_cond_t*cond, const pthread_condattr_t*attr);\nintpthread_cond_destroy(pthread_cond_t*cond);\nInitializes a condition variable (pointed to by cond) whose\nAttributes are defined in the attribute object attr\nIf at some point in a program a condition variable is no longer required, \nCondition Variables for Synchronization\nintpthread_cond_timedwait(pthread_cond_t*cond, pthread_mutex_t*mutex,\nconst structtimespec*abstime);\n1. Thread can perform a wait on a condition variable until a specified\ntime expires. \n2. At this point, the thread wakes up by itself if it does not receive a signal or a\nbroadcast.","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":18,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_18_1764046150963","subject":"map"}}],["b6cd9f6c-e08d-40bf-969e-13681e9e82ef",{"pageContent":"Producer-Consumer Using Condition Variables\npthread_cond_tcond_queue_empty, cond_queue_full; \npthread_mutex_ttask_queue_cond_lock; \ninttask_available; \n/* other data structures here */ \nmain() { \n/* declarations and initializations */ \ntask_available= 0; \npthread_init(); \npthread_cond_init(&cond_queue_empty, NULL); \npthread_cond_init(&cond_queue_full, NULL); \npthread_mutex_init(&task_queue_cond_lock, NULL); \n/* create and join producer and consumer threads */ \n} \n\nProducer-Consumer Using Condition Variables \nvoid *producer(void *producer_thread_data) { \nintinserted; \nwhile (!done()) { \ncreate_task(); \npthread_mutex_lock(&task_queue_cond_lock); \nwhile (task_available== 1) \npthread_cond_wait(&cond_queue_empty, &task_queue_cond_lock);\ninsert_into_queue(); \ntask_available= 1; \npthread_cond_signal(&cond_queue_full); \npthread_mutex_unlock(&task_queue_cond_lock); \n} \n}","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":19,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_19_1764046150963","subject":"map"}}],["b5c1df01-b009-470f-8823-4407f9406226",{"pageContent":"Producer-Consumer Using Condition Variables \nvoid *consumer(void *consumer_thread_data) { \nwhile (!done()) { \npthread_mutex_lock(&task_queue_cond_lock); \nwhile (task_available== 0) \npthread_cond_wait(&cond_queue_full, &task_queue_cond_lock); \nmy_task= extract_from_queue(); \ntask_available= 0; \npthread_cond_signal(&cond_queue_empty); \npthread_mutex_unlock(&task_queue_cond_lock); \nprocess_task(my_task); \n} \n} \n\nControlling Thread and Synchronization Attributes \n•The PthreadsAPI allows a programmer to change the default \nattributes of entities using attributes objects. \n•An attributes object is a data-structure that describes entity (thread, \nmutex, condition variable) properties. \n•Once these properties are set, the attributes object can be passed to \nthe method initializing the entity. \n•Enhances modularity, readability, and ease of modification. \nIntpthread_attr_init( pthread_attr_t*attr);\ninitializes the attributes object attrto the default values","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":20,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_20_1764046150963","subject":"map"}}],["41e54d64-567f-49e1-9d3d-199acd2ece1f",{"pageContent":"Attributes Objects for Threads \n•Use pthread_attr_initto create an attributes object. \n•Individual properties associated with the attributes object can be \nchanged using the following functions: \npthread_attr_setdetachstate, \npthread_attr_setguardsize_np, \npthread_attr_setstacksize, \npthread_attr_setinheritsched,\npthread_attr_setschedpolicy, and\npthread_attr_setschedparam\n\nThread Cancellation\nintpthread_cancel( pthread_tthread);\n•When a call to this function is made, a cancellation is sent to the \nspecified\nThread\n•The function returns a 0 on successful completion.\n\nComposite Synchronization Constructs\n•By design, Pthreads provide support for a basic set of operations. \n•Higher level constructs can be built using basic synchronization \nconstructs. \n•We discuss two such constructs -read-write locks and barriers.","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":21,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_21_1764046150963","subject":"map"}}],["14f2a1e6-4f02-473c-b6bc-9525206a2bc9",{"pageContent":"Read-Write Locks \n•In many applications, a data structure is read frequently but written infrequently. \nFor such applications, we should use read-write locks. \n•multiple reads can proceed without any coherence problems. \nHowever, writes must be serialized.\n•A read lock is granted when there are other threads that may already have read \nlocks. \n•If there is a write lock on the data (or if there are queued write locks), the thread \nperforms a condition wait. \n•If there are multiple threads requesting a write lock, they must perform a \ncondition wait. \n•With this description, we can design functions for read locks mylib_rwlock_rlock, \nwrite locks mylib_rwlock_wlock, and unlocking \nmylib_rwlock_unlock.","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":22,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_22_1764046150963","subject":"map"}}],["6320a25a-0c0a-4298-996a-f3a6c466d2d3",{"pageContent":"Read-Write Locks \n•The lock data type mylib_rwlock_t holds the following: \n•a count of the number of readers, \n•the writer (a 0/1 integer specifying whether a writer is present), \n•a condition variable readers_proceedthat is signaled when readers can \nproceed, \n•a condition variable writer_proceedthat is signaled when one of the \nwriters can proceed, \n•a count pending_writersof pending writers, and \n•a mutex read_write_lockassociated with the shared data structure\n\nRead-Write Locks \ntypedefstruct{ \nintreaders; \nintwriter; \npthread_cond_treaders_proceed; \npthread_cond_twriter_proceed; \nintpending_writers; \npthread_mutex_tread_write_lock; \n} mylib_rwlock_t; \nvoid mylib_rwlock_init(mylib_rwlock_t*l) { \nl -> readers = l -> writer = l -> pending_writers= 0; \npthread_mutex_init(&(l -> read_write_lock), NULL); \npthread_cond_init(&(l -> readers_proceed), NULL); \npthread_cond_init(&(l -> writer_proceed), NULL); \n}","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":23,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_23_1764046150963","subject":"map"}}],["3f23572b-3576-4382-976a-5a69783ed565",{"pageContent":"Read-Write Locks \nvoid mylib_rwlock_rlock(mylib_rwlock_t*l) { \n/* if there is a write lock or pending writers, perform condition wait.. else \nincrement count of readers and grant read lock */ \npthread_mutex_lock(&(l -> read_write_lock)); \nwhile ((l -> pending_writers> 0) || (l -> writer > 0)) \npthread_cond_wait(&(l -> readers_proceed), \n&(l -> read_write_lock)); \nl -> readers ++; \npthread_mutex_unlock(&(l -> read_write_lock)); \n} \n\nRead-Write Locks\nvoid mylib_rwlock_wlock(mylib_rwlock_t *l) { \n/* if there are readers or writers, increment pending writers count and \nwait. On being woken, decrement pending writers count and increment \nwriter count */ \npthread_mutex_lock(&(l -> read_write_lock)); \nwhile ((l -> writer > 0) || (l -> readers > 0)) { \nl -> pending_writers ++; \npthread_cond_wait(&(l -> writer_proceed), \n&(l -> read_write_lock)); \n} \nl -> pending_writers --; \nl -> writer ++; \npthread_mutex_unlock(&(l -> read_write_lock)); \n}","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":24,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_24_1764046150963","subject":"map"}}],["5495882c-1014-4d1c-a66c-4ee771cd8a9c",{"pageContent":"Read-Write Locks \nvoid mylib_rwlock_unlock(mylib_rwlock_t*l) { \n/* if there is a write lock then unlock, else if there are read locks, \ndecrement count of read locks. If the count is 0 and there is a pending \nwriter, let it through, else if there are pending readers, let them all go \nthrough */ \npthread_mutex_lock(&(l -> read_write_lock)); \nif (l -> writer > 0) \nl -> writer = 0; \nelse if (l -> readers > 0) \nl -> readers --; \npthread_mutex_unlock(&(l -> read_write_lock)); \nif ((l -> readers == 0) && (l -> pending_writers> 0)) \npthread_cond_signal(&(l -> writer_proceed)); \nelse if (l -> readers > 0) \npthread_cond_broadcast(&(l -> readers_proceed)); \n}","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":25,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_25_1764046150963","subject":"map"}}],["7caf2dc4-8cea-41ed-aca9-03801e24e5db",{"pageContent":"Barriers \n•As in MPI, a barrier holds a thread until all threads participating in the barrier \nhave reached it. \n•Barriers can be implemented using a counter, a mutex and a condition variable. \n•A single integer is used to keep track of the number of threads that have reached \nthe barrier. \n•If the count is less than the total number of threads, the threads execute a \ncondition wait. \n•The last thread entering (and setting the count to the number of threads) wakes \nup all the threads using a condition broadcast.\n\nBarriers \ntypedef struct {\npthread_mutex_t count_lock;\npthread_cond_t ok_to_proceed;\nint count;\n} mylib_barrier_t;\nvoid mylib_init_barrier(mylib_barrier_t *b) {\nb -> count = 0;\npthread_mutex_init(&(b -> count_lock), NULL);\npthread_cond_init(&(b -> ok_to_proceed), NULL);\n}","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":26,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_26_1764046150963","subject":"map"}}],["60102ef6-217d-488a-b9a8-03199d8a91e4",{"pageContent":"Barriers\nvoid mylib_barrier (mylib_barrier_t *b, int num_threads) \n{\npthread_mutex_lock(&(b -> count_lock));\nb -> count ++;\nif (b -> count == num_threads) {\nb -> count = 0;\npthread_cond_broadcast(&(b -> ok_to_proceed));\n}\nelse\nwhile (pthread_cond_wait(&(b -> ok_to_proceed),\n&(b -> count_lock)) != 0);\npthread_mutex_unlock(&(b -> count_lock));\n}\n\nBarrier\n•Execution time of 1000 sequential and logarithmic barriers as a function of number of threads on a 32 \nprocessor SGI Origin 2000.\n\nImplement  DAXPY loop using pthread(32threads)","metadata":{"filename":"1764046150821-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:49:10.963Z","chunkIndex":27,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046150821-Unit2-Pthreads.pdf","id":"map_1764046150821-Unit2-Pthreads.pdf_chunk_27_1764046150963","subject":"map"}}],["f62a02c6-3b46-44c9-8566-94a26c9356ae",{"pageContent":"Unit II -Programming Shared Address Space Platforms:\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.\n  \nCS72-MCA\n\nDistributed memory systems\nDistributed memory\nEach processorhas its own private memory.\nComputational tasks can only operate on local \ndata,\nif remote data is required, \nthe computational task must communicate \nwith one or more remote processors.\nCommunication through the message passing.\nRecap\n \n \nFig: A multiprocessor system with a distributed memory (loosely coupled \nsystem)\nCS72-MCA\n\nShared memory systems\nA multiprocessor system with shared memory (tightly coupled system)\nRecap\nall processors can access all the main memory address space.\nShared variables access in the main memory\nFetching instructions for execution in processors is also done from a \nshared memory\n  \nCS72-MCA","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":0,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_0_1764046206202","subject":"map"}}],["abdd8dc2-4433-4ba6-b893-969b35e38379",{"pageContent":"Threaded Programming Models\n•Library-based models —\n•all data is shared, unless otherwise specified \n•Examples: Pthreads, Intel Threading Building Blocks, Java Concurrency, Boost, \nMicrosoft .NetTask Parallel Library •\n•Directive-based models\n•e.g., OpenMP—shared and private data —\n•Thread creation and synchronization \n•Programming languages —\n•CilkPlus (Intel, GCC) —CUDA (NVIDIA) —Habanero-Java (Rice/Georgia Tech)\n \n\nParallel Programming\n1.Synchronization between concurrent tasks \n2.Communication of intermediate results\nShared address space architectures -\n-Implicitly specified since some (or all) of the memory is accessible to all the processors.\n-Threadsassume that all memory is global\n \n\nThread Basics\n•A thread is a single stream of control in the flow of a program  and it \nis a basic unit of CPU utilization.\nThread\n•Thread ID\n•Program counter\n•Register \n•setStack\nShares resources with other threads within the same process","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":1,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_1_1764046206202","subject":"map"}}],["f9be3d69-56d1-4c42-9298-0a13c6aca617",{"pageContent":"Thread Basics \n•The logical machine model of a thread-based programming paradigm. \n\nWhy Threads?\n•Threads provide software portability. \n•Inherent support for latency hiding. \n•Scheduling and load balancing. \n•Ease of programming and widespread use. \n \n\n•for (row = 0; row < n; row++) \nfor (column = 0; column < n; column++) \nc[row][column] = \ndot_product( get_row(a, row), \nget_col(b, col)); \ncan be transformed to: \nfor (row = 0; row < n; row++) \nfor (column = 0; column < n; column++) \nc[row][column] = \ncreate_thread( dot_product(get_row(a, \nrow),    get_col(b, \ncol))); \nProduct of two dense matrices of size n x n.\nhttps://www.tiny.cc/bhh  \nCS72-MCA\n\nThe POSIX Thread API\n•Number of vendors provide vendor-specific thread APIs\n•Pthreads-IEEE specifies a standard 1003.1c-1995, POSIX API\n•POSIX has emerged as the standard threads API\n•Other thread API: NT threads, Solaris threads, Java threads, etc","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":2,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_2_1764046206202","subject":"map"}}],["196a8125-0836-4618-afc6-01f0d7dc68c5",{"pageContent":"Thread Basics: Creation and Termination \n•Pthreads provides two basic functions for specifying concurrency in a \nprogram: \n#include <pthread.h> \nint pthread_create ( \npthread_t *thread_handle, const pthread_attr_t *attribute, \nvoid * (*thread_function)(void *), \nvoid *arg); \nint pthread_join ( \npthread_t thread, \nvoid **ptr); \n•The function pthread_create invokes function thread_function as a \nthread \n\nCreate thread\n•intpthread_create( pthread_t*thread, pthread_attr_t*attr,       void \n*(*thread_function)(void *), void *arg);\n•1st arg–pointer to the identifier of the created thread\n•2nd arg–thread attributes. If null, then the thread is created with default \nattributes\n•3rd arg–pointer to the function the thread will execute\n•4th arg–the argument of the executed function\n•returns 0 for success","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":3,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_3_1764046206202","subject":"map"}}],["9b9fbc4e-f21d-475d-ac4d-72524363e8a5",{"pageContent":"Waiting threads\nintpthread_join( pthread_tthread, void **thread_return)\n•main thread will wait for daughter thread threadto finish\n•1st arg–the thread to wait for\n•2nd arg–pointer to a pointer to the return value from the thread\n•returns 0 for success\n•threads should always be joined; otherwise, a thread might keep on running even \nwhen the main thread has already terminated\n\nEstimating Pi using the Monte Carlo Method\nThe area of the circle is πr\n2\n,\nThe area of the square is width\n2\n= (2r)\n2\n= 4r\n2\n. \nIf we divide the area of the circle, by the area \nof the square we get π/4.\n \nπ ≈ 4 x (number of points in the circle / total number of points)\n  \nCS72-MCA","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":4,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_4_1764046206202","subject":"map"}}],["656e19eb-f5b8-48e9-b575-224023f2326d",{"pageContent":"Thread Basics: Creation and Termination \n(Example) \n#include <pthread.h> \n#include <stdlib.h> \n#define MAX_THREADS 512 \nvoid *compute_pi (void *); \n.... \nmain() { \n... \npthread_t p_threads[MAX_THREADS]; \npthread_attr_t attr; \npthread_attr_init (&attr); \nfor (i=0; i< num_threads; i++) { \nhits[i] = i; \npthread_create(&p_threads[i], &attr, compute_pi, \n(void *) &hits[i]); \n} \nfor (i=0; i< num_threads; i++) { \npthread_join(p_threads[i], NULL); \ntotal_hits += hits[i]; \n} \n... \n} \n\nThread Basics: Creation and Termination \n(Example) \n#include <pthread.h> \n#include <stdlib.h> \n#define MAX_THREADS 512 \nvoid *compute_pi (void *); \n.... \nmain() { \n... \npthread_t p_threads[MAX_THREADS]; \npthread_attr_t attr; \npthread_attr_init (&attr); \nfor (i=0; i< num_threads; i++) { \nhits[i] = i; \npthread_create(&p_threads[i], &attr, compute_pi, \n(void *) &hits[i]); \n} \nfor (i=0; i< num_threads; i++) { \npthread_join(p_threads[i], NULL); \ntotal_hits += hits[i]; \n} \n... \n} \n\n \nCS72-MCA","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":5,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_5_1764046206202","subject":"map"}}],["124ab5a2-0f6a-4c43-9afa-d16aee3c8b57",{"pageContent":"CS72-MCA\n\nThread Basics: Creation and Termination \n(Example) \nvoid *compute_pi(void *s) { \nintseed, i, *hit_pointer; \ndouble rand_no_x, rand_no_y; \nintlocal_hits; \nhit_pointer= (int*) s; \nseed = *hit_pointer; \nlocal_hits= 0; \nfor (i= 0; i< sample_points_per_thread; i++) { \nrand_no_x=(double)(rand_r(&seed))/(double)((2<<14)-1); \nrand_no_y=(double)(rand_r(&seed))/(double)((2<<14)-1); \nif (((rand_no_x-0.5) * (rand_no_x-0.5) + \n(rand_no_y-0.5) * (rand_no_y-0.5)) < 0.25) \nlocal_hits++; \nseed *= i; \n} \n*hit_pointer= local_hits; \npthread_exit(0); \n}\n\nProgramming and Performance Notes \n•Note the use of the function rand_r(instead of superior random \nnumber generators such as drand48). \n•Executing this on a 4-processor SGI Origin, we observe a 3.91 fold \nspeedup at 32 threads. This corresponds to a parallel efficiency of \n0.98! \n•We can also modify the program slightly to observe the effect of false-\nsharing. \n•The program can also be used to assess the secondary cache line size.","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":6,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_6_1764046206202","subject":"map"}}],["aac5ae11-00ec-4d5e-a8da-ba048bc524a8",{"pageContent":"Programming and Performance Notes \n•Execution time of the compute_piprogram.\n\nSynchronization Primitives in Pthreads\n•Tasks work together to manipulate data and accomplish a given task. \n•When multiple threads attempt to manipulate the same data item the \nresults can often be incoherent if proper care is not taken to synchronize \nthem \n•Much of the effort associated with writing correct threaded programs is \nspent on synchronizing concurrent threads with respect to their data \naccesses or scheduling\nMutual Exclusion for Shared Variables\nhttps://www.tiny.cc/bhh \nCS72-MCA","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":7,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_7_1764046206202","subject":"map"}}],["e6022385-f00f-4167-91ff-30404ef013f6",{"pageContent":"•Assume that there are two threads, \n•The initial value of best_costis 100, \n•The values of my_costare 50 and 75 at threads t1 and t2, respectively. \n•If both threads execute the condition inside the if statement concurrently, then both threads \nenter the then part of the statement. \n•Depending on which thread executes first, the value of best_costat the end could be either \n50 or 75. \nhttps://www.tiny.cc/bhh  \nCS72-MCA\n\nThere are two problems here:\n1. non-deterministic nature of the result;\n2. more importantly, the value 75 of best_cost is inconsistent in the sense that\n  no serialization of the two threads can possibly yield this result.\nResult of the computation depends on the race between competing\n    threads\n• Critical segment- segment that must be executed by only one thread at any\n    time.\n• Threaded APIs provide support for implementing critical sections and\n    atomic operations using\nmutex-locks\nhttps://www.tiny.cc/bhh CS72-MCA","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":8,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_8_1764046206202","subject":"map"}}],["0afb395e-e588-4064-99d1-09e6b92e6e4d",{"pageContent":"•Critical segments in Pthreadsare implemented using mutexlocks. \n•Mutex-locks have two states:\n•locked and unlocked\n•At any point of time, only one thread can lock a mutexlock. A lock is an \natomic operation. \n•A thread entering a critical segment first tries to get a lock. It goes \nahead when the lock is granted. \nMutual Exclusion \n\nMutual Exclusion \nThe PthreadsAPI provides the following functions for handling mutex-\nlocks: \nintpthread_mutex_lock( \npthread_mutex_t*mutex_lock); \nintpthread_mutex_unlock(\npthread_mutex_t*mutex_lock); \nintpthread_mutex_init( \npthread_mutex_t*mutex_lock, \nconst pthread_mutexattr_t*lock_attr);","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":9,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_9_1764046206202","subject":"map"}}],["1b1819ea-b46a-4980-a230-7143482192c0",{"pageContent":"Mutual Exclusion\n•We can now write our previously incorrect code segment as: \npthread_mutex_tminimum_value_lock; \n... \nmain() { \n.... \npthread_mutex_init(&minimum_value_lock, NULL);\n.... \n} \nvoid *find_min(void *list_ptr) { \n.... \npthread_mutex_lock(&minimum_value_lock); \nif (my_min< minimum_value) \nminimum_value= my_min; \n/* and unlock the mutex*/ \npthread_mutex_unlock(&minimum_value_lock); \n} \nfunction to initialize a mutex-lock to its \nunlocked state\n•If the mutex-lock is already locked, the\ncalling thread blocks\n•otherwise the mutex-lock is locked and \nthe calling thread returns\n•a thread must unlock the mutex-lock  \n•If it does not do so, no other thread will be able to \nenter this section,\n•(typically resulting deadlock.)","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":10,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_10_1764046206202","subject":"map"}}],["5a22b317-1f33-4458-b2cc-0918dca38fed",{"pageContent":"Producer-Consumer Using Locks \n•The producer-consumer scenario imposes the following constraints: \n•The producer thread must not overwrite the shared buffer when the \nprevious task has not been picked up by a consumer thread. \n•The consumer threads must not pick up tasks until there is something \npresent in the shared data structure. \n•Individual consumer threads should pick up tasks one at a time.\nConstraints \n\nMutexTypes \n•Normal \n•—thread deadlocks if tries to lock a mutexit already has locked \n•Recursive \n•—single thread may lock a mutexas many times as it wants –\nincrements a count on the number of locks —thread relinquishes \nlock when mutexcount becomes zero \n•Errorcheck\n•—report error when a thread tries to lock a mutexit already \nlocked —report error if a thread unlocks a mutexlocked by \nanother\npthread_mutex_init(&minimum_value_lock, NULL);\nMutexTypes","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":11,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_11_1764046206202","subject":"map"}}],["8c6f3a59-0425-4b60-a762-53368512e596",{"pageContent":"Overheads of Locking \n•Locks represent serialization points since critical sections must be executed by \nthreads one after the other. \n•Encapsulating large segments of the program within locks can lead to significant \nperformance degradation. \n•It is often possible to reduce the idling overhead associated with locks using an \nalternate function, pthread_mutex_trylock. \nintpthread_mutex_trylock(pthread_mutex_t*mutex_lock); \n•pthread_mutex_trylockis typically much faster than \npthread_mutex_lockon typical systems s\n•since it does not have to deal with queues associated with locks for multiple threads waiting on \nthe lock. \n•enables a thread to do something else if a lock is unavailable","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":12,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_12_1764046206202","subject":"map"}}],["d4a41f17-7e11-4fdd-aa3a-967444c83ca3",{"pageContent":"Alleviating Locking Overhead (Example) \n/* Finding k matches in a list */ \nvoid *find_entries(void *start_pointer) { \n/* This is the thread function */ \nstructdatabase_record*next_record; \nintcount; \ncurrent_pointer= start_pointer; \ndo { \nnext_record= find_next_entry(current_pointer); \ncount = output_record(next_record); \n} while (count < requested_number_of_records); \n} \nintoutput_record(structdatabase_record*record_ptr) { \nintcount; \npthread_mutex_lock(&output_count_lock); \noutput_count++; \ncount = output_count; \npthread_mutex_unlock(&output_count_lock); \nif (count <= requested_number_of_records) \nprint_record(record_ptr); \nreturn (count); \n}","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":13,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_13_1764046206202","subject":"map"}}],["793066a5-1ed2-4906-a6ee-8616ad5faa9f",{"pageContent":"Alleviating Locking Overhead (Example) \n/* rewritten output_recordfunction */ \nintoutput_record(structdatabase_record*record_ptr) { \nintcount; \nintlock_status; \nlock_status=pthread_mutex_trylock(&output_count_lock); \nif (lock_status== EBUSY) { \ninsert_into_local_list(record_ptr); \nreturn(0); \n} \nelse { \ncount = output_count; \noutput_count+= number_on_local_list+ 1; \npthread_mutex_unlock(&output_count_lock); \nprint_records(record_ptr, local_list, \nrequested_number_of_records-count); \nreturn(count + number_on_local_list+ 1); \n} \n} \n\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.\n\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":14,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_14_1764046206202","subject":"map"}}],["573470b8-dfb4-4160-ab4f-59d1bfed8120",{"pageContent":"Condition Variables for Synchronization\n• A condition variable is a data object used for synchronizing threads \n• This variable allows a thread to block itself until specified data\n    reaches a predefined state\n• Always use condition variables together with a mutex lock.\nThe shared variable task_available must become 1 before the consumer threads can be \nsignaled.\nThe boolean condition task_available == 1 is referred to as a predicate.\n• The condition variables to atomically block threads until a \nparticular condition is true.","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":15,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_15_1764046206202","subject":"map"}}],["41ca0366-019c-4bfa-95ab-bc4d689ffa86",{"pageContent":"Condition Variables for Synchronization\n•If the predicate is not true, the thread waits on the condition variable associated \nwith the predicate using the function pthread_cond_wait. \n•intpthread_cond_wait(pthread_cond_t*cond, pthread_mutex_t\n*mutex);\n•A call to this function blocks the execution of the thread until it receives a \nsignal from another thread\nintpthread_cond_signal(pthread_cond_t*cond);\n1. Unblocks at least one thread that is currently waiting on the condition variablecond.\n2. The producer then relinquishes its lock on mutexby explicitly calling pthread_mutex_unlock\n3. allowing one of the blocked consumer threads to consume the task\nintpthread_cond_broadcast(pthread_cond_t*cond);\nwake all threads that are waiting on the condition variable","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":16,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_16_1764046206202","subject":"map"}}],["f954193c-b153-4b3c-96a0-865ac8af7d3c",{"pageContent":"•Using a condition variable —\n•thread can block itself until a condition becomes true\n•thread locks a mutex\n•tests a predicate defined on a shared variable if predicate is false, then wait on the \ncondition variable waiting on condition variable unlocks associated mutex\n•when some thread makes a predicate true\n•Thread can signal the condition variable to either wake one waiting thread wake all \nwaiting threads\n•–when thread releases the mutex, it is passed to first waiter\nhttps://www.tiny.cc/bhh                                                  \nCS72-HPC","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":17,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_17_1764046206202","subject":"map"}}],["9f02e65d-6550-4e49-9ef1-c029bfe21bf4",{"pageContent":"intpthread_cond_init(pthread_cond_t*cond, const pthread_condattr_t*attr);\nintpthread_cond_destroy(pthread_cond_t*cond);\nInitializes a condition variable (pointed to by cond) whose\nAttributes are defined in the attribute object attr\nIf at some point in a program a condition variable is no longer required, \nCondition Variables for Synchronization\nintpthread_cond_timedwait(pthread_cond_t*cond, pthread_mutex_t*mutex,\nconst structtimespec*abstime);\n1. Thread can perform a wait on a condition variable until a specified\ntime expires. \n2. At this point, the thread wakes up by itself if it does not receive a signal or a\nbroadcast.","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":18,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_18_1764046206202","subject":"map"}}],["09cf80d4-ec95-4ab7-a027-e40e123bb827",{"pageContent":"Producer-Consumer Using Condition Variables\npthread_cond_tcond_queue_empty, cond_queue_full; \npthread_mutex_ttask_queue_cond_lock; \ninttask_available; \n/* other data structures here */ \nmain() { \n/* declarations and initializations */ \ntask_available= 0; \npthread_init(); \npthread_cond_init(&cond_queue_empty, NULL); \npthread_cond_init(&cond_queue_full, NULL); \npthread_mutex_init(&task_queue_cond_lock, NULL); \n/* create and join producer and consumer threads */ \n} \n\nProducer-Consumer Using Condition Variables \nvoid *producer(void *producer_thread_data) { \nintinserted; \nwhile (!done()) { \ncreate_task(); \npthread_mutex_lock(&task_queue_cond_lock); \nwhile (task_available== 1) \npthread_cond_wait(&cond_queue_empty, &task_queue_cond_lock);\ninsert_into_queue(); \ntask_available= 1; \npthread_cond_signal(&cond_queue_full); \npthread_mutex_unlock(&task_queue_cond_lock); \n} \n}","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":19,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_19_1764046206202","subject":"map"}}],["d6e7da37-763e-421b-9408-7c0aadd3d14e",{"pageContent":"Producer-Consumer Using Condition Variables \nvoid *consumer(void *consumer_thread_data) { \nwhile (!done()) { \npthread_mutex_lock(&task_queue_cond_lock); \nwhile (task_available== 0) \npthread_cond_wait(&cond_queue_full, &task_queue_cond_lock); \nmy_task= extract_from_queue(); \ntask_available= 0; \npthread_cond_signal(&cond_queue_empty); \npthread_mutex_unlock(&task_queue_cond_lock); \nprocess_task(my_task); \n} \n} \n\nControlling Thread and Synchronization Attributes \n•The PthreadsAPI allows a programmer to change the default \nattributes of entities using attributes objects. \n•An attributes object is a data-structure that describes entity (thread, \nmutex, condition variable) properties. \n•Once these properties are set, the attributes object can be passed to \nthe method initializing the entity. \n•Enhances modularity, readability, and ease of modification. \nIntpthread_attr_init( pthread_attr_t*attr);\ninitializes the attributes object attrto the default values","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":20,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_20_1764046206202","subject":"map"}}],["77ba1449-c33a-41b2-83f5-e4119cba7e56",{"pageContent":"Attributes Objects for Threads \n•Use pthread_attr_initto create an attributes object. \n•Individual properties associated with the attributes object can be \nchanged using the following functions: \npthread_attr_setdetachstate, \npthread_attr_setguardsize_np, \npthread_attr_setstacksize, \npthread_attr_setinheritsched,\npthread_attr_setschedpolicy, and\npthread_attr_setschedparam\n\nThread Cancellation\nintpthread_cancel( pthread_tthread);\n•When a call to this function is made, a cancellation is sent to the \nspecified\nThread\n•The function returns a 0 on successful completion.\n\nComposite Synchronization Constructs\n•By design, Pthreads provide support for a basic set of operations. \n•Higher level constructs can be built using basic synchronization \nconstructs. \n•We discuss two such constructs -read-write locks and barriers.","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":21,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_21_1764046206202","subject":"map"}}],["27636362-2803-4112-b18e-8877f3599df6",{"pageContent":"Read-Write Locks \n•In many applications, a data structure is read frequently but written infrequently. \nFor such applications, we should use read-write locks. \n•multiple reads can proceed without any coherence problems. \nHowever, writes must be serialized.\n•A read lock is granted when there are other threads that may already have read \nlocks. \n•If there is a write lock on the data (or if there are queued write locks), the thread \nperforms a condition wait. \n•If there are multiple threads requesting a write lock, they must perform a \ncondition wait. \n•With this description, we can design functions for read locks mylib_rwlock_rlock, \nwrite locks mylib_rwlock_wlock, and unlocking \nmylib_rwlock_unlock.","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":22,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_22_1764046206202","subject":"map"}}],["5689e256-5dd5-479f-92f7-e18b072a5410",{"pageContent":"Read-Write Locks \n•The lock data type mylib_rwlock_t holds the following: \n•a count of the number of readers, \n•the writer (a 0/1 integer specifying whether a writer is present), \n•a condition variable readers_proceedthat is signaled when readers can \nproceed, \n•a condition variable writer_proceedthat is signaled when one of the \nwriters can proceed, \n•a count pending_writersof pending writers, and \n•a mutex read_write_lockassociated with the shared data structure\n\nRead-Write Locks \ntypedefstruct{ \nintreaders; \nintwriter; \npthread_cond_treaders_proceed; \npthread_cond_twriter_proceed; \nintpending_writers; \npthread_mutex_tread_write_lock; \n} mylib_rwlock_t; \nvoid mylib_rwlock_init(mylib_rwlock_t*l) { \nl -> readers = l -> writer = l -> pending_writers= 0; \npthread_mutex_init(&(l -> read_write_lock), NULL); \npthread_cond_init(&(l -> readers_proceed), NULL); \npthread_cond_init(&(l -> writer_proceed), NULL); \n}","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":23,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_23_1764046206202","subject":"map"}}],["b498be48-4d9c-4014-8b95-a4eb05045b2f",{"pageContent":"Read-Write Locks \nvoid mylib_rwlock_rlock(mylib_rwlock_t*l) { \n/* if there is a write lock or pending writers, perform condition wait.. else \nincrement count of readers and grant read lock */ \npthread_mutex_lock(&(l -> read_write_lock)); \nwhile ((l -> pending_writers> 0) || (l -> writer > 0)) \npthread_cond_wait(&(l -> readers_proceed), \n&(l -> read_write_lock)); \nl -> readers ++; \npthread_mutex_unlock(&(l -> read_write_lock)); \n} \n\nRead-Write Locks\nvoid mylib_rwlock_wlock(mylib_rwlock_t *l) { \n/* if there are readers or writers, increment pending writers count and \nwait. On being woken, decrement pending writers count and increment \nwriter count */ \npthread_mutex_lock(&(l -> read_write_lock)); \nwhile ((l -> writer > 0) || (l -> readers > 0)) { \nl -> pending_writers ++; \npthread_cond_wait(&(l -> writer_proceed), \n&(l -> read_write_lock)); \n} \nl -> pending_writers --; \nl -> writer ++; \npthread_mutex_unlock(&(l -> read_write_lock)); \n}","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":24,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_24_1764046206202","subject":"map"}}],["6f2ce680-9ac3-4ec2-b2d5-2d43535e1fd8",{"pageContent":"Read-Write Locks \nvoid mylib_rwlock_unlock(mylib_rwlock_t*l) { \n/* if there is a write lock then unlock, else if there are read locks, \ndecrement count of read locks. If the count is 0 and there is a pending \nwriter, let it through, else if there are pending readers, let them all go \nthrough */ \npthread_mutex_lock(&(l -> read_write_lock)); \nif (l -> writer > 0) \nl -> writer = 0; \nelse if (l -> readers > 0) \nl -> readers --; \npthread_mutex_unlock(&(l -> read_write_lock)); \nif ((l -> readers == 0) && (l -> pending_writers> 0)) \npthread_cond_signal(&(l -> writer_proceed)); \nelse if (l -> readers > 0) \npthread_cond_broadcast(&(l -> readers_proceed)); \n}","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":25,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_25_1764046206202","subject":"map"}}],["590c0747-f928-47c4-871f-e282a16e1bed",{"pageContent":"Barriers \n•As in MPI, a barrier holds a thread until all threads participating in the barrier \nhave reached it. \n•Barriers can be implemented using a counter, a mutex and a condition variable. \n•A single integer is used to keep track of the number of threads that have reached \nthe barrier. \n•If the count is less than the total number of threads, the threads execute a \ncondition wait. \n•The last thread entering (and setting the count to the number of threads) wakes \nup all the threads using a condition broadcast.\n\nBarriers \ntypedef struct {\npthread_mutex_t count_lock;\npthread_cond_t ok_to_proceed;\nint count;\n} mylib_barrier_t;\nvoid mylib_init_barrier(mylib_barrier_t *b) {\nb -> count = 0;\npthread_mutex_init(&(b -> count_lock), NULL);\npthread_cond_init(&(b -> ok_to_proceed), NULL);\n}","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":26,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_26_1764046206202","subject":"map"}}],["66866c25-088e-4306-97a2-cd0d5956d86b",{"pageContent":"Barriers\nvoid mylib_barrier (mylib_barrier_t *b, int num_threads) \n{\npthread_mutex_lock(&(b -> count_lock));\nb -> count ++;\nif (b -> count == num_threads) {\nb -> count = 0;\npthread_cond_broadcast(&(b -> ok_to_proceed));\n}\nelse\nwhile (pthread_cond_wait(&(b -> ok_to_proceed),\n&(b -> count_lock)) != 0);\npthread_mutex_unlock(&(b -> count_lock));\n}\n\nBarrier\n•Execution time of 1000 sequential and logarithmic barriers as a function of number of threads on a 32 \nprocessor SGI Origin 2000.\n\nImplement  DAXPY loop using pthread(32threads)","metadata":{"filename":"1764046206097-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:50:06.202Z","chunkIndex":27,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046206097-Unit2-Pthreads.pdf","id":"map_1764046206097-Unit2-Pthreads.pdf_chunk_27_1764046206202","subject":"map"}}],["03cbaf69-a55b-4253-a17b-c75ddb028cb6",{"pageContent":"Unit II -Programming Shared Address Space Platforms:\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.\n  \nCS72-MCA\n\nDistributed memory systems\nDistributed memory\nEach processorhas its own private memory.\nComputational tasks can only operate on local \ndata,\nif remote data is required, \nthe computational task must communicate \nwith one or more remote processors.\nCommunication through the message passing.\nRecap\n \n \nFig: A multiprocessor system with a distributed memory (loosely coupled \nsystem)\nCS72-MCA\n\nShared memory systems\nA multiprocessor system with shared memory (tightly coupled system)\nRecap\nall processors can access all the main memory address space.\nShared variables access in the main memory\nFetching instructions for execution in processors is also done from a \nshared memory\n  \nCS72-MCA","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.127Z","chunkIndex":0,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_0_1764046382127","subject":"map"}}],["4d0c4939-a51a-46bb-81b5-efd331515bdc",{"pageContent":"Threaded Programming Models\n•Library-based models —\n•all data is shared, unless otherwise specified \n•Examples: Pthreads, Intel Threading Building Blocks, Java Concurrency, Boost, \nMicrosoft .NetTask Parallel Library •\n•Directive-based models\n•e.g., OpenMP—shared and private data —\n•Thread creation and synchronization \n•Programming languages —\n•CilkPlus (Intel, GCC) —CUDA (NVIDIA) —Habanero-Java (Rice/Georgia Tech)\n \n\nParallel Programming\n1.Synchronization between concurrent tasks \n2.Communication of intermediate results\nShared address space architectures -\n-Implicitly specified since some (or all) of the memory is accessible to all the processors.\n-Threadsassume that all memory is global\n \n\nThread Basics\n•A thread is a single stream of control in the flow of a program  and it \nis a basic unit of CPU utilization.\nThread\n•Thread ID\n•Program counter\n•Register \n•setStack\nShares resources with other threads within the same process","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":1,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_1_1764046382129","subject":"map"}}],["57a3a4be-6623-4046-bd81-89345786b356",{"pageContent":"Thread Basics \n•The logical machine model of a thread-based programming paradigm. \n\nWhy Threads?\n•Threads provide software portability. \n•Inherent support for latency hiding. \n•Scheduling and load balancing. \n•Ease of programming and widespread use. \n \n\n•for (row = 0; row < n; row++) \nfor (column = 0; column < n; column++) \nc[row][column] = \ndot_product( get_row(a, row), \nget_col(b, col)); \ncan be transformed to: \nfor (row = 0; row < n; row++) \nfor (column = 0; column < n; column++) \nc[row][column] = \ncreate_thread( dot_product(get_row(a, \nrow),    get_col(b, \ncol))); \nProduct of two dense matrices of size n x n.\nhttps://www.tiny.cc/bhh  \nCS72-MCA\n\nThe POSIX Thread API\n•Number of vendors provide vendor-specific thread APIs\n•Pthreads-IEEE specifies a standard 1003.1c-1995, POSIX API\n•POSIX has emerged as the standard threads API\n•Other thread API: NT threads, Solaris threads, Java threads, etc","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":2,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_2_1764046382129","subject":"map"}}],["65b4847a-8cd1-4656-8d02-4774f000e260",{"pageContent":"Thread Basics: Creation and Termination \n•Pthreads provides two basic functions for specifying concurrency in a \nprogram: \n#include <pthread.h> \nint pthread_create ( \npthread_t *thread_handle, const pthread_attr_t *attribute, \nvoid * (*thread_function)(void *), \nvoid *arg); \nint pthread_join ( \npthread_t thread, \nvoid **ptr); \n•The function pthread_create invokes function thread_function as a \nthread \n\nCreate thread\n•intpthread_create( pthread_t*thread, pthread_attr_t*attr,       void \n*(*thread_function)(void *), void *arg);\n•1st arg–pointer to the identifier of the created thread\n•2nd arg–thread attributes. If null, then the thread is created with default \nattributes\n•3rd arg–pointer to the function the thread will execute\n•4th arg–the argument of the executed function\n•returns 0 for success","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":3,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_3_1764046382129","subject":"map"}}],["524bf46d-395d-41ce-b427-043db4e91518",{"pageContent":"Waiting threads\nintpthread_join( pthread_tthread, void **thread_return)\n•main thread will wait for daughter thread threadto finish\n•1st arg–the thread to wait for\n•2nd arg–pointer to a pointer to the return value from the thread\n•returns 0 for success\n•threads should always be joined; otherwise, a thread might keep on running even \nwhen the main thread has already terminated\n\nEstimating Pi using the Monte Carlo Method\nThe area of the circle is πr\n2\n,\nThe area of the square is width\n2\n= (2r)\n2\n= 4r\n2\n. \nIf we divide the area of the circle, by the area \nof the square we get π/4.\n \nπ ≈ 4 x (number of points in the circle / total number of points)\n  \nCS72-MCA","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":4,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_4_1764046382129","subject":"map"}}],["ca6ab68b-7966-4e73-bab9-f72835a6da08",{"pageContent":"Thread Basics: Creation and Termination \n(Example) \n#include <pthread.h> \n#include <stdlib.h> \n#define MAX_THREADS 512 \nvoid *compute_pi (void *); \n.... \nmain() { \n... \npthread_t p_threads[MAX_THREADS]; \npthread_attr_t attr; \npthread_attr_init (&attr); \nfor (i=0; i< num_threads; i++) { \nhits[i] = i; \npthread_create(&p_threads[i], &attr, compute_pi, \n(void *) &hits[i]); \n} \nfor (i=0; i< num_threads; i++) { \npthread_join(p_threads[i], NULL); \ntotal_hits += hits[i]; \n} \n... \n} \n\nThread Basics: Creation and Termination \n(Example) \n#include <pthread.h> \n#include <stdlib.h> \n#define MAX_THREADS 512 \nvoid *compute_pi (void *); \n.... \nmain() { \n... \npthread_t p_threads[MAX_THREADS]; \npthread_attr_t attr; \npthread_attr_init (&attr); \nfor (i=0; i< num_threads; i++) { \nhits[i] = i; \npthread_create(&p_threads[i], &attr, compute_pi, \n(void *) &hits[i]); \n} \nfor (i=0; i< num_threads; i++) { \npthread_join(p_threads[i], NULL); \ntotal_hits += hits[i]; \n} \n... \n} \n\n \nCS72-MCA","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":5,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_5_1764046382129","subject":"map"}}],["e5c68bbc-4dc6-4c98-a375-f593026f9d7d",{"pageContent":"CS72-MCA\n\nThread Basics: Creation and Termination \n(Example) \nvoid *compute_pi(void *s) { \nintseed, i, *hit_pointer; \ndouble rand_no_x, rand_no_y; \nintlocal_hits; \nhit_pointer= (int*) s; \nseed = *hit_pointer; \nlocal_hits= 0; \nfor (i= 0; i< sample_points_per_thread; i++) { \nrand_no_x=(double)(rand_r(&seed))/(double)((2<<14)-1); \nrand_no_y=(double)(rand_r(&seed))/(double)((2<<14)-1); \nif (((rand_no_x-0.5) * (rand_no_x-0.5) + \n(rand_no_y-0.5) * (rand_no_y-0.5)) < 0.25) \nlocal_hits++; \nseed *= i; \n} \n*hit_pointer= local_hits; \npthread_exit(0); \n}\n\nProgramming and Performance Notes \n•Note the use of the function rand_r(instead of superior random \nnumber generators such as drand48). \n•Executing this on a 4-processor SGI Origin, we observe a 3.91 fold \nspeedup at 32 threads. This corresponds to a parallel efficiency of \n0.98! \n•We can also modify the program slightly to observe the effect of false-\nsharing. \n•The program can also be used to assess the secondary cache line size.","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":6,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_6_1764046382129","subject":"map"}}],["056195c3-7864-4657-9b7c-4e29bcde4409",{"pageContent":"Programming and Performance Notes \n•Execution time of the compute_piprogram.\n\nSynchronization Primitives in Pthreads\n•Tasks work together to manipulate data and accomplish a given task. \n•When multiple threads attempt to manipulate the same data item the \nresults can often be incoherent if proper care is not taken to synchronize \nthem \n•Much of the effort associated with writing correct threaded programs is \nspent on synchronizing concurrent threads with respect to their data \naccesses or scheduling\nMutual Exclusion for Shared Variables\nhttps://www.tiny.cc/bhh \nCS72-MCA","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":7,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_7_1764046382129","subject":"map"}}],["8b048f92-8215-400b-a20d-86a0c61f8cd7",{"pageContent":"•Assume that there are two threads, \n•The initial value of best_costis 100, \n•The values of my_costare 50 and 75 at threads t1 and t2, respectively. \n•If both threads execute the condition inside the if statement concurrently, then both threads \nenter the then part of the statement. \n•Depending on which thread executes first, the value of best_costat the end could be either \n50 or 75. \nhttps://www.tiny.cc/bhh  \nCS72-MCA\n\nThere are two problems here:\n1. non-deterministic nature of the result;\n2. more importantly, the value 75 of best_cost is inconsistent in the sense that\n  no serialization of the two threads can possibly yield this result.\nResult of the computation depends on the race between competing\n    threads\n• Critical segment- segment that must be executed by only one thread at any\n    time.\n• Threaded APIs provide support for implementing critical sections and\n    atomic operations using\nmutex-locks\nhttps://www.tiny.cc/bhh CS72-MCA","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":8,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_8_1764046382129","subject":"map"}}],["2e3863ed-348a-43a7-b8a3-bd4ec0a39ef0",{"pageContent":"•Critical segments in Pthreadsare implemented using mutexlocks. \n•Mutex-locks have two states:\n•locked and unlocked\n•At any point of time, only one thread can lock a mutexlock. A lock is an \natomic operation. \n•A thread entering a critical segment first tries to get a lock. It goes \nahead when the lock is granted. \nMutual Exclusion \n\nMutual Exclusion \nThe PthreadsAPI provides the following functions for handling mutex-\nlocks: \nintpthread_mutex_lock( \npthread_mutex_t*mutex_lock); \nintpthread_mutex_unlock(\npthread_mutex_t*mutex_lock); \nintpthread_mutex_init( \npthread_mutex_t*mutex_lock, \nconst pthread_mutexattr_t*lock_attr);","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":9,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_9_1764046382129","subject":"map"}}],["b83cb4b1-e170-44ee-ae9a-c2170faa7bbd",{"pageContent":"Mutual Exclusion\n•We can now write our previously incorrect code segment as: \npthread_mutex_tminimum_value_lock; \n... \nmain() { \n.... \npthread_mutex_init(&minimum_value_lock, NULL);\n.... \n} \nvoid *find_min(void *list_ptr) { \n.... \npthread_mutex_lock(&minimum_value_lock); \nif (my_min< minimum_value) \nminimum_value= my_min; \n/* and unlock the mutex*/ \npthread_mutex_unlock(&minimum_value_lock); \n} \nfunction to initialize a mutex-lock to its \nunlocked state\n•If the mutex-lock is already locked, the\ncalling thread blocks\n•otherwise the mutex-lock is locked and \nthe calling thread returns\n•a thread must unlock the mutex-lock  \n•If it does not do so, no other thread will be able to \nenter this section,\n•(typically resulting deadlock.)","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":10,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_10_1764046382129","subject":"map"}}],["c72a1463-5c1d-4050-87b0-b43fc9a96e9f",{"pageContent":"Producer-Consumer Using Locks \n•The producer-consumer scenario imposes the following constraints: \n•The producer thread must not overwrite the shared buffer when the \nprevious task has not been picked up by a consumer thread. \n•The consumer threads must not pick up tasks until there is something \npresent in the shared data structure. \n•Individual consumer threads should pick up tasks one at a time.\nConstraints \n\nMutexTypes \n•Normal \n•—thread deadlocks if tries to lock a mutexit already has locked \n•Recursive \n•—single thread may lock a mutexas many times as it wants –\nincrements a count on the number of locks —thread relinquishes \nlock when mutexcount becomes zero \n•Errorcheck\n•—report error when a thread tries to lock a mutexit already \nlocked —report error if a thread unlocks a mutexlocked by \nanother\npthread_mutex_init(&minimum_value_lock, NULL);\nMutexTypes","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":11,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_11_1764046382129","subject":"map"}}],["aac6c770-f7e9-4826-9b28-73e36798322c",{"pageContent":"Overheads of Locking \n•Locks represent serialization points since critical sections must be executed by \nthreads one after the other. \n•Encapsulating large segments of the program within locks can lead to significant \nperformance degradation. \n•It is often possible to reduce the idling overhead associated with locks using an \nalternate function, pthread_mutex_trylock. \nintpthread_mutex_trylock(pthread_mutex_t*mutex_lock); \n•pthread_mutex_trylockis typically much faster than \npthread_mutex_lockon typical systems s\n•since it does not have to deal with queues associated with locks for multiple threads waiting on \nthe lock. \n•enables a thread to do something else if a lock is unavailable","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":12,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_12_1764046382129","subject":"map"}}],["075a6169-db60-4eab-97fc-0deb7e6c4e5a",{"pageContent":"Alleviating Locking Overhead (Example) \n/* Finding k matches in a list */ \nvoid *find_entries(void *start_pointer) { \n/* This is the thread function */ \nstructdatabase_record*next_record; \nintcount; \ncurrent_pointer= start_pointer; \ndo { \nnext_record= find_next_entry(current_pointer); \ncount = output_record(next_record); \n} while (count < requested_number_of_records); \n} \nintoutput_record(structdatabase_record*record_ptr) { \nintcount; \npthread_mutex_lock(&output_count_lock); \noutput_count++; \ncount = output_count; \npthread_mutex_unlock(&output_count_lock); \nif (count <= requested_number_of_records) \nprint_record(record_ptr); \nreturn (count); \n}","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":13,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_13_1764046382129","subject":"map"}}],["75c61631-52fe-4515-8c08-99ffc42c1809",{"pageContent":"Alleviating Locking Overhead (Example) \n/* rewritten output_recordfunction */ \nintoutput_record(structdatabase_record*record_ptr) { \nintcount; \nintlock_status; \nlock_status=pthread_mutex_trylock(&output_count_lock); \nif (lock_status== EBUSY) { \ninsert_into_local_list(record_ptr); \nreturn(0); \n} \nelse { \ncount = output_count; \noutput_count+= number_on_local_list+ 1; \npthread_mutex_unlock(&output_count_lock); \nprint_records(record_ptr, local_list, \nrequested_number_of_records-count); \nreturn(count + number_on_local_list+ 1); \n} \n} \n\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.\n\nThread\nBasics\nThe POSIX Thread API,\nThread Creation and Termination,\nSynchronization Primitives in Pthreads, \nControlling Thread and Synchronization Attributes,\nThread Cancellation, Composite Synchronization Constructs.","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":14,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_14_1764046382129","subject":"map"}}],["55b6fed8-3541-4484-b7a3-fece673e92a1",{"pageContent":"Condition Variables for Synchronization\n• A condition variable is a data object used for synchronizing threads \n• This variable allows a thread to block itself until specified data\n    reaches a predefined state\n• Always use condition variables together with a mutex lock.\nThe shared variable task_available must become 1 before the consumer threads can be \nsignaled.\nThe boolean condition task_available == 1 is referred to as a predicate.\n• The condition variables to atomically block threads until a \nparticular condition is true.","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":15,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_15_1764046382129","subject":"map"}}],["6025ad07-7317-4c62-88e0-7864615a01b1",{"pageContent":"Condition Variables for Synchronization\n•If the predicate is not true, the thread waits on the condition variable associated \nwith the predicate using the function pthread_cond_wait. \n•intpthread_cond_wait(pthread_cond_t*cond, pthread_mutex_t\n*mutex);\n•A call to this function blocks the execution of the thread until it receives a \nsignal from another thread\nintpthread_cond_signal(pthread_cond_t*cond);\n1. Unblocks at least one thread that is currently waiting on the condition variablecond.\n2. The producer then relinquishes its lock on mutexby explicitly calling pthread_mutex_unlock\n3. allowing one of the blocked consumer threads to consume the task\nintpthread_cond_broadcast(pthread_cond_t*cond);\nwake all threads that are waiting on the condition variable","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":16,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_16_1764046382129","subject":"map"}}],["ba97dc2a-62f3-4ee1-aec3-3f717f3d3c03",{"pageContent":"•Using a condition variable —\n•thread can block itself until a condition becomes true\n•thread locks a mutex\n•tests a predicate defined on a shared variable if predicate is false, then wait on the \ncondition variable waiting on condition variable unlocks associated mutex\n•when some thread makes a predicate true\n•Thread can signal the condition variable to either wake one waiting thread wake all \nwaiting threads\n•–when thread releases the mutex, it is passed to first waiter\nhttps://www.tiny.cc/bhh                                                  \nCS72-HPC","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":17,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_17_1764046382129","subject":"map"}}],["0cc19832-46ba-40bb-93a2-38b713ec6831",{"pageContent":"intpthread_cond_init(pthread_cond_t*cond, const pthread_condattr_t*attr);\nintpthread_cond_destroy(pthread_cond_t*cond);\nInitializes a condition variable (pointed to by cond) whose\nAttributes are defined in the attribute object attr\nIf at some point in a program a condition variable is no longer required, \nCondition Variables for Synchronization\nintpthread_cond_timedwait(pthread_cond_t*cond, pthread_mutex_t*mutex,\nconst structtimespec*abstime);\n1. Thread can perform a wait on a condition variable until a specified\ntime expires. \n2. At this point, the thread wakes up by itself if it does not receive a signal or a\nbroadcast.","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":18,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_18_1764046382129","subject":"map"}}],["e85cba9f-cd7f-41ed-9ef6-6003268f1944",{"pageContent":"Producer-Consumer Using Condition Variables\npthread_cond_tcond_queue_empty, cond_queue_full; \npthread_mutex_ttask_queue_cond_lock; \ninttask_available; \n/* other data structures here */ \nmain() { \n/* declarations and initializations */ \ntask_available= 0; \npthread_init(); \npthread_cond_init(&cond_queue_empty, NULL); \npthread_cond_init(&cond_queue_full, NULL); \npthread_mutex_init(&task_queue_cond_lock, NULL); \n/* create and join producer and consumer threads */ \n} \n\nProducer-Consumer Using Condition Variables \nvoid *producer(void *producer_thread_data) { \nintinserted; \nwhile (!done()) { \ncreate_task(); \npthread_mutex_lock(&task_queue_cond_lock); \nwhile (task_available== 1) \npthread_cond_wait(&cond_queue_empty, &task_queue_cond_lock);\ninsert_into_queue(); \ntask_available= 1; \npthread_cond_signal(&cond_queue_full); \npthread_mutex_unlock(&task_queue_cond_lock); \n} \n}","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":19,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_19_1764046382129","subject":"map"}}],["1e377bba-1be8-4faf-b2b5-03a8bcfc89cf",{"pageContent":"Producer-Consumer Using Condition Variables \nvoid *consumer(void *consumer_thread_data) { \nwhile (!done()) { \npthread_mutex_lock(&task_queue_cond_lock); \nwhile (task_available== 0) \npthread_cond_wait(&cond_queue_full, &task_queue_cond_lock); \nmy_task= extract_from_queue(); \ntask_available= 0; \npthread_cond_signal(&cond_queue_empty); \npthread_mutex_unlock(&task_queue_cond_lock); \nprocess_task(my_task); \n} \n} \n\nControlling Thread and Synchronization Attributes \n•The PthreadsAPI allows a programmer to change the default \nattributes of entities using attributes objects. \n•An attributes object is a data-structure that describes entity (thread, \nmutex, condition variable) properties. \n•Once these properties are set, the attributes object can be passed to \nthe method initializing the entity. \n•Enhances modularity, readability, and ease of modification. \nIntpthread_attr_init( pthread_attr_t*attr);\ninitializes the attributes object attrto the default values","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":20,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_20_1764046382129","subject":"map"}}],["6e2b3c34-f533-4b78-8c4d-f7c7472e603c",{"pageContent":"Attributes Objects for Threads \n•Use pthread_attr_initto create an attributes object. \n•Individual properties associated with the attributes object can be \nchanged using the following functions: \npthread_attr_setdetachstate, \npthread_attr_setguardsize_np, \npthread_attr_setstacksize, \npthread_attr_setinheritsched,\npthread_attr_setschedpolicy, and\npthread_attr_setschedparam\n\nThread Cancellation\nintpthread_cancel( pthread_tthread);\n•When a call to this function is made, a cancellation is sent to the \nspecified\nThread\n•The function returns a 0 on successful completion.\n\nComposite Synchronization Constructs\n•By design, Pthreads provide support for a basic set of operations. \n•Higher level constructs can be built using basic synchronization \nconstructs. \n•We discuss two such constructs -read-write locks and barriers.","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":21,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_21_1764046382129","subject":"map"}}],["75993aae-94e2-4be4-b01d-ece7cd61eda2",{"pageContent":"Read-Write Locks \n•In many applications, a data structure is read frequently but written infrequently. \nFor such applications, we should use read-write locks. \n•multiple reads can proceed without any coherence problems. \nHowever, writes must be serialized.\n•A read lock is granted when there are other threads that may already have read \nlocks. \n•If there is a write lock on the data (or if there are queued write locks), the thread \nperforms a condition wait. \n•If there are multiple threads requesting a write lock, they must perform a \ncondition wait. \n•With this description, we can design functions for read locks mylib_rwlock_rlock, \nwrite locks mylib_rwlock_wlock, and unlocking \nmylib_rwlock_unlock.","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":22,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_22_1764046382129","subject":"map"}}],["c78f8e40-5d12-4f19-a8da-1cc47dabe10d",{"pageContent":"Read-Write Locks \n•The lock data type mylib_rwlock_t holds the following: \n•a count of the number of readers, \n•the writer (a 0/1 integer specifying whether a writer is present), \n•a condition variable readers_proceedthat is signaled when readers can \nproceed, \n•a condition variable writer_proceedthat is signaled when one of the \nwriters can proceed, \n•a count pending_writersof pending writers, and \n•a mutex read_write_lockassociated with the shared data structure\n\nRead-Write Locks \ntypedefstruct{ \nintreaders; \nintwriter; \npthread_cond_treaders_proceed; \npthread_cond_twriter_proceed; \nintpending_writers; \npthread_mutex_tread_write_lock; \n} mylib_rwlock_t; \nvoid mylib_rwlock_init(mylib_rwlock_t*l) { \nl -> readers = l -> writer = l -> pending_writers= 0; \npthread_mutex_init(&(l -> read_write_lock), NULL); \npthread_cond_init(&(l -> readers_proceed), NULL); \npthread_cond_init(&(l -> writer_proceed), NULL); \n}","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":23,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_23_1764046382129","subject":"map"}}],["26fefeaa-1eee-4dc7-9ee3-d3cf2e34ccd5",{"pageContent":"Read-Write Locks \nvoid mylib_rwlock_rlock(mylib_rwlock_t*l) { \n/* if there is a write lock or pending writers, perform condition wait.. else \nincrement count of readers and grant read lock */ \npthread_mutex_lock(&(l -> read_write_lock)); \nwhile ((l -> pending_writers> 0) || (l -> writer > 0)) \npthread_cond_wait(&(l -> readers_proceed), \n&(l -> read_write_lock)); \nl -> readers ++; \npthread_mutex_unlock(&(l -> read_write_lock)); \n} \n\nRead-Write Locks\nvoid mylib_rwlock_wlock(mylib_rwlock_t *l) { \n/* if there are readers or writers, increment pending writers count and \nwait. On being woken, decrement pending writers count and increment \nwriter count */ \npthread_mutex_lock(&(l -> read_write_lock)); \nwhile ((l -> writer > 0) || (l -> readers > 0)) { \nl -> pending_writers ++; \npthread_cond_wait(&(l -> writer_proceed), \n&(l -> read_write_lock)); \n} \nl -> pending_writers --; \nl -> writer ++; \npthread_mutex_unlock(&(l -> read_write_lock)); \n}","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":24,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_24_1764046382129","subject":"map"}}],["0978f47b-53b7-4488-8504-e83d6cd1ce27",{"pageContent":"Read-Write Locks \nvoid mylib_rwlock_unlock(mylib_rwlock_t*l) { \n/* if there is a write lock then unlock, else if there are read locks, \ndecrement count of read locks. If the count is 0 and there is a pending \nwriter, let it through, else if there are pending readers, let them all go \nthrough */ \npthread_mutex_lock(&(l -> read_write_lock)); \nif (l -> writer > 0) \nl -> writer = 0; \nelse if (l -> readers > 0) \nl -> readers --; \npthread_mutex_unlock(&(l -> read_write_lock)); \nif ((l -> readers == 0) && (l -> pending_writers> 0)) \npthread_cond_signal(&(l -> writer_proceed)); \nelse if (l -> readers > 0) \npthread_cond_broadcast(&(l -> readers_proceed)); \n}","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":25,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_25_1764046382129","subject":"map"}}],["75cdfd1a-e2ea-4cd2-82a0-407c040e093d",{"pageContent":"Barriers \n•As in MPI, a barrier holds a thread until all threads participating in the barrier \nhave reached it. \n•Barriers can be implemented using a counter, a mutex and a condition variable. \n•A single integer is used to keep track of the number of threads that have reached \nthe barrier. \n•If the count is less than the total number of threads, the threads execute a \ncondition wait. \n•The last thread entering (and setting the count to the number of threads) wakes \nup all the threads using a condition broadcast.\n\nBarriers \ntypedef struct {\npthread_mutex_t count_lock;\npthread_cond_t ok_to_proceed;\nint count;\n} mylib_barrier_t;\nvoid mylib_init_barrier(mylib_barrier_t *b) {\nb -> count = 0;\npthread_mutex_init(&(b -> count_lock), NULL);\npthread_cond_init(&(b -> ok_to_proceed), NULL);\n}","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":26,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_26_1764046382129","subject":"map"}}],["899c10a8-b3c1-4f65-b91c-dbf313314aee",{"pageContent":"Barriers\nvoid mylib_barrier (mylib_barrier_t *b, int num_threads) \n{\npthread_mutex_lock(&(b -> count_lock));\nb -> count ++;\nif (b -> count == num_threads) {\nb -> count = 0;\npthread_cond_broadcast(&(b -> ok_to_proceed));\n}\nelse\nwhile (pthread_cond_wait(&(b -> ok_to_proceed),\n&(b -> count_lock)) != 0);\npthread_mutex_unlock(&(b -> count_lock));\n}\n\nBarrier\n•Execution time of 1000 sequential and logarithmic barriers as a function of number of threads on a 32 \nprocessor SGI Origin 2000.\n\nImplement  DAXPY loop using pthread(32threads)","metadata":{"filename":"1764046381990-Unit2-Pthreads.pdf","uploadDate":"2025-11-25T04:53:02.129Z","chunkIndex":27,"totalChunks":28,"filepath":"/Users/apv03/Desktop/genai/genai_proj/backend/uploads/map/1764046381990-Unit2-Pthreads.pdf","id":"map_1764046381990-Unit2-Pthreads.pdf_chunk_27_1764046382129","subject":"map"}}]],{"0":"91d547fe-c422-43b9-87cc-fb96a439735b","1":"76767869-7e4f-4562-8efa-443b0bb346a5","2":"7e2333b9-d204-40c2-b1b6-d42c4a22f88f","3":"c8084ab5-2637-4dc7-96e2-d1126e9f381f","4":"106c7c2f-0848-439d-b9c6-983b3311faa7","5":"d547c541-34dd-442c-9a33-86158be61145","6":"f496454c-2564-4493-be24-b532d98429ce","7":"d80dd31d-f94c-41dc-b049-c14fdd271b30","8":"b1dc0552-7446-4aa8-a51d-fde8b1eb60f4","9":"8f5af811-97fc-4ef2-a1c6-38fe6affd99a","10":"d43bb26b-054c-4c95-ad36-2071066b1437","11":"e1e99f21-fc17-4c78-8ab4-93ffaa8a3b58","12":"ba3e9357-d6e5-4056-9b1a-6c45e8c148be","13":"9c2ebd93-3c48-4b08-a453-582dbbf30502","14":"ecd818d8-7e43-4d07-80d9-6ef85c08e3f0","15":"5520f5d9-606a-4f5c-92ef-df7e720b8ecf","16":"c1c5497f-cbd0-4022-9e52-6892f8932370","17":"1ec7cb16-97c1-42e6-8f5e-65a6108ecc7d","18":"94dc3167-2b70-4a5f-a572-fd4c99d8f511","19":"b6cd9f6c-e08d-40bf-969e-13681e9e82ef","20":"b5c1df01-b009-470f-8823-4407f9406226","21":"41e54d64-567f-49e1-9d3d-199acd2ece1f","22":"14f2a1e6-4f02-473c-b6bc-9525206a2bc9","23":"6320a25a-0c0a-4298-996a-f3a6c466d2d3","24":"3f23572b-3576-4382-976a-5a69783ed565","25":"5495882c-1014-4d1c-a66c-4ee771cd8a9c","26":"7caf2dc4-8cea-41ed-aca9-03801e24e5db","27":"60102ef6-217d-488a-b9a8-03199d8a91e4","28":"f62a02c6-3b46-44c9-8566-94a26c9356ae","29":"abdd8dc2-4433-4ba6-b893-969b35e38379","30":"f9be3d69-56d1-4c42-9298-0a13c6aca617","31":"196a8125-0836-4618-afc6-01f0d7dc68c5","32":"9b9fbc4e-f21d-475d-ac4d-72524363e8a5","33":"656e19eb-f5b8-48e9-b575-224023f2326d","34":"124ab5a2-0f6a-4c43-9afa-d16aee3c8b57","35":"aac5ae11-00ec-4d5e-a8da-ba048bc524a8","36":"e6022385-f00f-4167-91ff-30404ef013f6","37":"0afb395e-e588-4064-99d1-09e6b92e6e4d","38":"1b1819ea-b46a-4980-a230-7143482192c0","39":"5a22b317-1f33-4458-b2cc-0918dca38fed","40":"8c6f3a59-0425-4b60-a762-53368512e596","41":"d4a41f17-7e11-4fdd-aa3a-967444c83ca3","42":"793066a5-1ed2-4906-a6ee-8616ad5faa9f","43":"573470b8-dfb4-4160-ab4f-59d1bfed8120","44":"41ca0366-019c-4bfa-95ab-bc4d689ffa86","45":"f954193c-b153-4b3c-96a0-865ac8af7d3c","46":"9f02e65d-6550-4e49-9ef1-c029bfe21bf4","47":"09cf80d4-ec95-4ab7-a027-e40e123bb827","48":"d6e7da37-763e-421b-9408-7c0aadd3d14e","49":"77ba1449-c33a-41b2-83f5-e4119cba7e56","50":"27636362-2803-4112-b18e-8877f3599df6","51":"5689e256-5dd5-479f-92f7-e18b072a5410","52":"b498be48-4d9c-4014-8b95-a4eb05045b2f","53":"6f2ce680-9ac3-4ec2-b2d5-2d43535e1fd8","54":"590c0747-f928-47c4-871f-e282a16e1bed","55":"66866c25-088e-4306-97a2-cd0d5956d86b","56":"03cbaf69-a55b-4253-a17b-c75ddb028cb6","57":"4d0c4939-a51a-46bb-81b5-efd331515bdc","58":"57a3a4be-6623-4046-bd81-89345786b356","59":"65b4847a-8cd1-4656-8d02-4774f000e260","60":"524bf46d-395d-41ce-b427-043db4e91518","61":"ca6ab68b-7966-4e73-bab9-f72835a6da08","62":"e5c68bbc-4dc6-4c98-a375-f593026f9d7d","63":"056195c3-7864-4657-9b7c-4e29bcde4409","64":"8b048f92-8215-400b-a20d-86a0c61f8cd7","65":"2e3863ed-348a-43a7-b8a3-bd4ec0a39ef0","66":"b83cb4b1-e170-44ee-ae9a-c2170faa7bbd","67":"c72a1463-5c1d-4050-87b0-b43fc9a96e9f","68":"aac6c770-f7e9-4826-9b28-73e36798322c","69":"075a6169-db60-4eab-97fc-0deb7e6c4e5a","70":"75c61631-52fe-4515-8c08-99ffc42c1809","71":"55b6fed8-3541-4484-b7a3-fece673e92a1","72":"6025ad07-7317-4c62-88e0-7864615a01b1","73":"ba97dc2a-62f3-4ee1-aec3-3f717f3d3c03","74":"0cc19832-46ba-40bb-93a2-38b713ec6831","75":"e85cba9f-cd7f-41ed-9ef6-6003268f1944","76":"1e377bba-1be8-4faf-b2b5-03a8bcfc89cf","77":"6e2b3c34-f533-4b78-8c4d-f7c7472e603c","78":"75993aae-94e2-4be4-b01d-ece7cd61eda2","79":"c78f8e40-5d12-4f19-a8da-1cc47dabe10d","80":"26fefeaa-1eee-4dc7-9ee3-d3cf2e34ccd5","81":"0978f47b-53b7-4488-8504-e83d6cd1ce27","82":"75cdfd1a-e2ea-4cd2-82a0-407c040e093d","83":"899c10a8-b3c1-4f65-b91c-dbf313314aee"}]